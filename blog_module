#!/bin/bash


function execute_mysql() {
	# Determines whether the client is being run inside or outside the container, then:
	# Enters the DBMS, submits the query, and returns the data to a file "output_dirty."
	if [ $(grep "Container: " /usr/local/share/blog_config.yml | sed 's/Container: //; s/ *$//') == "True" ]; then
		mysql --defaults-extra-file=/usr/local/share/blog_config_mysql.cnf -s -e "$1" | grep -v '^[-]*$' > output_dirty
	else
		docker-compose exec mysql_blog_interface mysql --defaults-extra-file=/usr/local/share/blog_config_mysql.cnf -e "$1" | grep -v '^[-]*$' > output_dirty
	fi
}


function sql() {
	# Read Branch
	if [ "$1" == "read" ]; then
		if [ "$2" == "all" ]; then
			
			echo "	SELECT *
         			FROM entries
				ORDER BY entry_number DESC;"

		elif [ "$2" == "last" ]; then
			
			echo "	SELECT *
                        	FROM entries
                        	WHERE entry_number = (
                                	SELECT MAX(entry_number)
                                	FROM entries
                                );"
		
		else
			
			echo "	SELECT *
                        	FROM entries
                        	WHERE entry_number IN ("$2")
                                ORDER BY entry_number DESC;"
	
		fi
	# Write Branch
	elif [ "$1" == "write" ]; then 
	
		echo "	INSERT INTO entries (entry) VALUES (
                		CONCAT('"$2"')
                	);

                	SELECT *
                	FROM entries
             	 	WHERE entry_number = (
                        	SELECT MAX(entry_number)
                        	FROM entries
                        );"
	
	# Edit Branch
	elif [ "$1" == "edit" ]; then
		if [ "$2" == "last" ]; then
	
			echo "	UPDATE entries
                        	SET entry = CONCAT('$3')
                       	 	WHERE entry_number = (
                                	SELECT MAX(entry_number)
                                	FROM (SELECT * FROM entries) AS temp
                                );

                        	SELECT *
                        	FROM entries
				WHERE entry_number = (
					SELECT MAX(entry_number)
					FROM entries
					);"

		else
	
			echo "	UPDATE entries
                        	SET entry = CONCAT('$3')
                        	WHERE (entry_number = "$2");

                        	SELECT *
                        	FROM entries
				WHERE (entry_number = "$2")
                                ORDER BY entry_number DESC;"

		fi
	# Delete Branch
	elif [ "$1" == "delete" ]; then
		if [ "$2" == "last" ]; then

			echo "DELETE FROM entries
                        	WHERE entry_number = (
                                	SELECT MAX(entry_number)
                                	FROM entries
                                	);

                        	SELECT *
                        	FROM entries
                                ORDER BY DESC;"

		else

			echo "DELETE FROM entries
                        	WHERE entry_number IN ("$2");

                        	SELECT *
                        	FROM entries
                                ORDER BY DESC;"
		
		fi
	fi
}


function prep_entry() {
	# Moves the entry to a temporary file to be formatted.
	cp "$1" entry_dirty

	# Formats the entry file such that it won't conflict with 
	# SQL commands and can be reversed upon retrieval.
        sed -i "s/'/', CHAR(39), '/g" entry_dirty
        sed -i "s/\"/', CHAR(34), '/g" entry_dirty
        sed -i "s/;/', CHAR(59), '/g" entry_dirty

	# Returns formatted text.
	echo "$(<entry_dirty)"
}


function clean_output() {
        # Reverse engineers some of the escape sequences that MySQL outputs.
        sed -i 's/\\t/\t/g' output_dirty
        sed -i 's/\\n/\n/g' output_dirty

	# Additional formatting to make things more digestable in a lightweight text editor.
	sed -i 's/^\([0-9]\+\s[0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}\s[0-9]\{2\}:[0-9]\{2\}:[0-9]\{2\}\)/\n\n\n\1\n/g' output_dirty

	# Moves the output to a long-term file once it's formatted.
        cp output_dirty output
} 


function show_output() {
	vim -c ":set wrap linebreak" output
}


function cleanup() {
	# Removes temp files.
	touch output_dirty
	rm output_dirty
	touch entry_dirty
	rm entry_dirty
}


function blog_read() {
	# Asks the user what they want to read if it wasn't specified in args.
        if [ "$1" == "" ]; then
                echo -e "Which entries would you like to read?\n\tex) 7\n\tex) 1, 2, 5\n\tex) last\n\tex) all"
                read read_nums
        else
                read_nums="$1"
        fi

	# Gets our query based on user input/args and executes.
        action=$(sql "read" "$read_nums" 2>/dev/null) 
        execute_mysql "$action"
	
	# Determines success and reports. Shows user their result if possible.
        if [ $? -eq 0 ]; then
                echo "Read successful."
		clean_output
		show_output
		cleanup
                exit 0
        else
		clean_output
		if [ "$(<output)" == "" ]; then
			if [ $(echo "$read_nums" | grep -oE '[0-9]+' | wc -l) -eq 1 ]; then
                		echo "That entry doesn't exist."
	                	cleanup	
				exit 1
			else
				echo "Those entries don't exist."
				cleanup
				exit 1
			fi
		else
               		echo "Something went wrong."
                	cleanup
			exit 1
		fi
        fi
}


function blog_write() {
	# If file was specified in args, we use that. If not, we use "entry."
        if [ "$1" == "" ]; then
                file_name="./entry"
        else
                file_name="$1"
        fi

	
	# Prep entry file by formatting for MySQL, determine SQL to be used, and execute.
        ENTRY_FILE=$(prep_entry "$file_name")
        action=$(sql "write" "$ENTRY_FILE")
	
        execute_mysql "$action" 


	# Report results to the user, show a finalized version of their write if requested.
        if [ $? -eq 0 ]; then
                echo "Write successful."

                echo "Read last entry?: (Y/N)"
                read read_ans

                if [ "$read_ans" == "Y" ] || [ "$read_ans" == "y" ]; then
			clean_output
                        show_output
                        cleanup
			exit 0
                else
                        cleanup
			exit 0
                fi
        else
                echo "Something went wrong."
                cleanup
		exit 1
        fi
}


function blog_edit() {
	# Asks the user what they want to edit if it wasn't specified in args.
        if [ "$1" == "" ]; then
                echo -e "Which entry would you like to overwrite?\n\tex) 7\n\tex)last"
                read edit_num
        else
                edit_num="$1"
        fi


	# If file was specified in args, we use that. If not, we use "entry."
        if [ "$2" == "" ]; then
                file_name="./entry"
        else
                file_name="$2"
        fi

	# Prep entry file by formatting for MySQL and determine SQL to be used.
        ENTRY_FILE=$(prep_entry "$file_name")
	action=$(sql "edit" "$edit_num" "$ENTRY_FILE")

	# Warns the user.
        echo "Are you sure you want to permanently overwrite this entry? (Y/N)"
        read edit_ans

	# Executes the SQL in the DBMS, report results to user, display all entries if requested.
        if [ $edit_ans == "Y" ] || [ $edit_ans == "y" ]; then
                execute_mysql "$action"
                if [ $? -eq 0 ]; then
			if [ "$(<output_dirty)" != "" ]; then
				echo "Edit successful."
			else
				echo "That entry dooesn't exist."
			fi
                        echo "Read your edited entry? (Y/N)"
                        read read_ans

                        if [ "$read_ans" == "Y" ] || [ "$read_ans" == "y" ]; then
				clean_output
                                show_output
                                cleanup
				exit 0
                        else
                                cleanup
				exit 0
                        fi
                else
                        echo "Something went wrong. Nothing has been overwritten."
                        cleanup
			exit 1
                fi
        elsei
                echo "Nothing has been overwritten."
                cleanup
		exit 0
        fi
}


function blog_delete() {
	# Asks the user what they want to edit if it wasn't specified in args.
        if [ "$1" == "" ]; then
                echo -e "Which entries would you like to delete?\n\tex) 7\n\tex) 1, 2, 5\n\tex) last"
                read del_nums
        else
                del_nums="$1"
        fi


	# Determines SQL to be used.
        action=$(sql "delete" "$del_nums" 2>/dev/null)
  
	# Warns the user.
	if [ $(echo "$del_nums" | grep -oE '[0-9]+' | wc -l) -eq 1 ]; then
		echo "Are you sure you want to permanently delete that entry? (Y/N)"
	else        
		echo "Are you sure you want to permanently delete these entries? (Y/N)"
	fi
        read del_ans

	# Deletes desired entries if confirmed and gives the user 
	# the option to view all entries to confirm.
        if [ $del_ans == "Y" ] || [ $del_ans == "y" ]; then
                execute_mysql "$action"
                if [ $? -eq 0 ]; then
			echo "Deletion successful."
                        echo "Read all entries? (Y/N)"
                        read read_ans
                        if [ "$read_ans" == "Y" ] || [ "$read_ans" == "y" ]; then
				clean_output
                                show_output
                                cleanup
				exit 0
                        else
                                cleanup
				exit 0
                        fi
                else
                        echo "Something went wrong. Nothing has been deleted."
                        cleanup
			exit 1
                fi
        else
                echo "Nothing has been deleted."
                cleanup
		exit 0
        fi
}



function blog_backup() {
	# Gets a snapshot of the backup before and after trying to overwrite it.	
        BEFORE_DUMP=$(<backup.sql)
	# Determines whether the client is being run inside or outside the container.
	if [ $(grep "Container: " /usr/local/share/blog_config.yml | sed 's/Container: //; s/ *$//') == "True" ]; then
        	mysqldump --default-character-set=utf8 --defaults-file=/usr/local/share/blog_config_mysql.cnf blog_entries > backup.sql
	else
		docker-compose exec mysql_blog_interface mysqldump --default-character-set=utf8 --defaults-file=/usr/local/share/blog_config_mysql.cnf blog_entries > backup.sql
	fi
        AFTER_DUMP=$(<backup.sql)

	# Checks if the snapshots are different to determine success.
        if [ "$BEFORE_DUMP" != "$AFTER_DUMP" ]; then
                echo "Backup successful."
                cleanup
		exit 0
        else
                echo "Something went wrong. Your backup was not updated."
        fi
}


function local_publish() {
	# Moves necessary files to a $PATH directory for ease of access.
        cp blog_module /usr/local/bin/blog_module
        cp blog /usr/local/bin/blog

	# Report results to user.
        if [ $? -eq 0 ]; then
                echo -e "Publish to /usr/local/bin successful.\nYou may now run commands using:\n\tblog ..."
                cleanup
		exit 0
        else
                echo "Something went wrong."
                cleanup
		exit 1
        fi
}
