#!/bin/bash


function execute_mysql() {
	
	DATABASE_NAME="blog_entries"
	CONTAINER_NAME="mysql_blog_interface"
	MYSQL_CONFIG_PATH="/usr/local/share/blog_config_mysql.cnf"
	BLOG_CONFIG_PATH="/usr/local/share/blog_config.yml"
	in_container="$(read_mysql_cnf Container)"
	sql="$1"

	# Determines whether the client is being run inside or outside the container, then:
	# Enters the DBMS, submits the query, and places the data in "output".
	case "$in_container" in
		True)
			output_dirty=$(mysql --defaults-extra-file="$MYSQL_CONFIG_PATH" -D "$DATABASE_NAME" -e "$sql")
			mysql_err="$?"
			;;
		False)
			output_dirty=$(docker-compose exec "$CONTAINER_NAME" mysql --defaults-extra-file="$MYSQL_CONFIG_PATH" -D "$DATABASE_NAME" -e "$sql")
			mysql_err=$(docker-compose exec "$CONTAINER_NAME" echo "$?")
			;;
		?)
			echo "You must have a \"Container=True/False\" configuration in "$BLOG_CONFIG_PATH""
			exit 1
			;;
	esac

	# Returns cleaned output and the MySQL exit code.
	output="$(clean_output "$output_dirty")"
	echo -e "$mysql_err $output"
}


function sql() {
	entry="$1"
	# Read Branch
	if [ "$action" == "read" ]; then
		# Entry only, no timestamps. This is used for edit prep.
		if [ "$style" == "clean" ]; then
			if [ "$entry_number" == "all" ]; then
			
				echo "	SELECT entry
         				FROM entries;"

			elif [ "$entry_number" == "last" ]; then
			
				echo "	SELECT entry
                        		FROM entries
                        		WHERE entry_number = (
                                		SELECT MAX(entry_number)
                                		FROM entries
                               	 	);"
		
			else
			
				echo "	SELECT entry
                        		FROM entries
                        		WHERE entry_number IN ("$entry_number");"
	
			fi
		# Entry Number, Timestamp, and Entry. This is used most of the time.
		else
			if [ "$entry_number" == "all" ]; then

                                echo "  SELECT *
                                        FROM entries;"

                        elif [ "$entry_number" == "last" ]; then

                                echo "  SELECT *
                                        FROM entries
                                        WHERE entry_number = (
                                                SELECT MAX(entry_number)
                                                FROM entries
                                        );"

                        else

                                echo "  SELECT *
                                        FROM entries
                                        WHERE entry_number IN ("$entry_number");"

                        fi
		fi
	# Write Branch
	elif [ "$action" == "write" ]; then 

		echo "	INSERT INTO entries (entry) VALUES (
                		CONCAT('"$entry"')
                	);"
	
	# Edit Branch
	elif [ "$action" == "edit" ]; then
		
		if [ "$entry_number" == "last" ]; then
	
			echo "	UPDATE entries
                        	SET entry = CONCAT('$entry')
                       	 	WHERE entry_number = (
                                	SELECT MAX(entry_number)
                                	FROM (SELECT * FROM entries) AS temp
                                );"

		else
	
			echo "	UPDATE entries
                        	SET entry = CONCAT('$entry')
                        	WHERE (entry_number = "$entry_number");"

		fi
	# Delete Branch
	elif [ "$action" == "delete" ]; then
		if [ "$entry_number" == "last" ]; then

			echo "	DELETE FROM entries
                        	WHERE entry_number = (                                                                                                          
					SELECT MAX(entry_number)                                                                                                
					FROM (SELECT * FROM entries) AS temp                                                                           
					);"

		else

			echo "	DELETE FROM entries
                        	WHERE entry_number IN ("$entry_number");"
		
		fi
	fi
}


function prep_entry() {
	# Moves the entry to a variable to be formatted.
	entry="$(<"$1")"

	# Replaces single quotes with MySQL-friendly syntax.
	entry_pass_one="$(echo "$entry" | sed "s/'/', CHAR(39), '/g")"
	# Replaces double quotes.
	entry_pass_two="$(echo "$entry_pass_one" | sed "s/\"/', CHAR(34), '/g")"
	# Replaces semicolons.
	entry_pass_three="$(echo "$entry_pass_two" | sed "s/;/', CHAR(59), '/g")"
	# Replaces newlines.
	entry_pass_four="$(echo "$entry_pass_three" | sed ":a;N;$!ba;s/\n/', CHAR(10), '/g")"

	# Returns formatted text.
	echo "$entry_pass_four"
}


function clean_output() {

        output_dirty="$1"	

	# Removes some cluttery output from the MySQL output.
	output_pass_one="$(echo "$output_dirty" | grep -v '^[-]*$')"
	# Handles different output fields to make things more visibly pleasant.
	output_pass_two="$(echo "$output_pass_one" | sed 's/^\([0-9]\+\s[0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}\s[0-9]\{2\}:[0-9]\{2\}:[0-9]\{2\}\)/\n\n\n\1\n/g')"
	# Removes the header displaying the fields outputted by MySQL.
	output_pass_three="$(echo "$output_pass_two" | sed '1d')"

	# Return the formatted output.
        echo "$output_pass_three"
} 


function read_mysql_cnf() {
	setting_check="$1: "
	if [ $(grep "$setting_check" /usr/local/share/blog_config.yml | sed 's/Container: //; s/ *$//') == "True" ]; then
		echo "True"
	else
		echo "False"
	fi
}


function debug() {
	execute_mysql
}

function blog_read() {
	# Asks the user what they want to read if it wasn't specified in options.
        if [ "$entry_number" == "" ]; then
                echo -e "Which entries would you like to read?\n\tex) 5\n\tex) 2, 4, 5\n\tex) last\n\tex) all"
                read entry_number
        fi

	# Gets our query based on user input/args and executes, stores output and mysql exit code.
        mysql_action=$(sql) 
	output_and_err=$(execute_mysql "$mysql_action")
	mysql_err="${output_and_err%% *}"
	output="${output_and_err#* }"
	
	# Determines success and reports. Shows user their result if possible.
        if [ "$mysql_err" == 0 ]; then
		if [ "$style" == "clean" ]; then
                       	echo -e "$output"
            	else
                	echo " "
			echo -e "$(echo "$output" | fold -s -w $(tput cols))"
                   	echo " "
          	fi
                exit 0
        else
		if [ "$output" == "" ]; then
			if [ "$(echo "$entry_number" | grep -oE '[0-9]+' | wc -l)" -eq 1 ]; then
                		echo "That entry doesn't exist."	
				exit 1
			else
				echo "Those entries don't exist."
				exit 1
			fi
		else
               		echo "Something went wrong."
			exit 1
		fi
        fi
}


function blog_write() {
	# If file was specified in option, we use that. If not, we use "entry."
        if [ "$file_name" == "" ]; then
                file_name="./entry"
		# Prompts user to write their entry.
                truncate -s 0 "$file_name"
                vim +"set wrap linebreak" -c "startinsert" "$file_name"
        fi
		
	echo "Are you sure you want to submit this entry? (Y/N)"
	read write_ans

	if [ "$write_ans" != "Y" ] && [ "$write_ans" != "y" ]; then
		echo "Nothing was submitted."
		exit 0
	else
	 	# Prep entry file by formatting for MySQL, determine SQL to be used.
        	ENTRY_FILE=$(prep_entry "$file_name")
        	mysql_action=$(sql "$ENTRY_FILE")

		# Executes --- stores MySQL exit code & cleaned output.
		output_and_err=$(execute_mysql "$mysql_action")
        	mysql_err="${output_and_err%% *}"
      	 	output="${output_and_err#* }"


		# Report results to the user, show a finalized version of their write if requested.
        	if [ "$mysql_err" !=  0 ]; then
	
			echo "Something went wrong."
                	exit 1

		else
                	echo "Write successful."
                	echo "Read last entry?: (Y/N)"
                	read read_ans

                	if [ "$read_ans" == "Y" ] || [ "$read_ans" == "y" ]; then
				echo " "
				echo -e "$(blog read -e last)"
				echo " "
				exit 0
                	else
				exit 0
                	fi
        	fi
	fi
}


function blog_edit() {
	# Asks the user what they want to edit if it wasn't specified in options.
        if [ "$entry_number" == "" ]; then
                echo -e "Which entry would you like to overwrite?\n\tex) 5\n\tex)last"
                read entry_number
        fi


	# If file was specified in options, we use that. If not, we use "entry."
        if [ "$file_name" == "" ]; then
                file_name="./entry"
        fi

	# Retrieves entry for editing.
	output=$(blog read -e "$entry_number" -s "clean")

	if [ "$output" == "" ]; then
		echo "That entry doesn't exist."
		exit 1
	else
		# Allows the user to edit the entry.
		echo "$output" > "$file_name"
		vim +"set wrap linebreak" -c "startinsert" "$file_name"

		# Warns the user.
        	echo "Are you sure you want to permanently overwrite this entry? (Y/N)"
        	read edit_ans

		# Executes the SQL in the DBMS, report results to user, display all entries if requested.
        	if [ "$edit_ans" != "Y" ] && [ "$edit_ans" != "y" ]; then
			echo "Nothing has been overwritten."
                        exit 0
		else
	 		# Prep entry file by formatting for MySQL and determine SQL to be used.
        		ENTRY_FILE="$(prep_entry "$file_name")"
        		mysql_action="$(sql "$ENTRY_FILE")"
			output_and_err="$(execute_mysql "$mysql_action")"
        		mysql_err="${output_and_err%% *}"
        		output="${output_and_err#* }"

               		if [ "$mysql_err" != "0" ]; then
				echo "Something went wrong. Nothing has been overwritten."
                                exit 1
			else
                       		echo "Read your edited entry? (Y/N)"
                        	read read_ans

                        	if [ "$read_ans" == "Y" ] || [ "$read_ans" == "y" ]; then
					echo " "
					echo -e "$(blog read -e "$entry_number")"
					echo " "
					exit 0
                        	else
					exit 0
                        	fi
                	fi
		fi
	fi
}


function blog_delete() {
	# Asks the user what they want to edit if it wasn't specified in options.
        if [ "$entry_number" == "" ]; then
                echo -e "Which entries would you like to delete?\n\tex) 5\n\tex) 2, 4, 5\n\tex) last"
                read entry_number
        fi

	# Checks if the entry exists, informs user, and performs a plural check.
	output="$(blog read -e "$entry_number")"
	if [[ ! "$output" =~ [^[:space:]] ]]; then	# Looks for anything except white space.
		if [ $(echo "$entry_number" | grep -oE '[0-9]+' | wc -l) -eq 1 ]; then
                	echo "That entry doesn't exist."
       		else
                	echo "Those entries don't exist."
		fi
	else
		# Warns the user. Singular/plural check.
		if [ $(echo "$entry_number" | grep -oE '[0-9]+' | wc -l) -le 1 ]; then
			echo "Are you sure you want to permanently delete that entry? (Y/N)"
		else        
			echo "Are you sure you want to permanently delete those entries? (Y/N)"
		fi
        	read del_ans

		# Deletes desired entries if approved and gives the user 
		# the option to view all entries to confirm.
        	if [ $del_ans == "Y" ] || [ $del_ans == "y" ]; then
                
			mysql_action=$(sql)
			output_and_err=$(execute_mysql "$mysql_action")
               		mysql_err="${output_and_err%% *}"

                	if [ "$mysql_err" == "0" ]; then
				echo "Deletion successful."
                        	echo "Read all entries? (Y/N)"
                        	read read_ans
                        	if [ "$read_ans" == "Y" ] || [ "$read_ans" == "y" ]; then
					echo "$(blog read -e all)"
					exit 0
                        	else
					exit 0
                        	fi
                	else
                        	echo "Something went wrong. Nothing has been deleted."
				exit 1
                	fi
        	else
                	echo "Nothing has been deleted."
			exit 0
		fi
        fi
}



function blog_backup() {
	# Checks for an alternate file name.
	if [ "$file_name" == "" ]; then
		file_name="backup.sql"
	fi 
	
	# Gets a snapshot of the backup before and after trying to overwrite it.	
	touch "$file_name"
	BEFORE_DUMP=$(<"$file_name")

	# Determines whether the client is being run inside or outside the container.
	if [ $(grep "Container: " /usr/local/share/blog_config.yml | sed 's/Container: //; s/ *$//') == "True" ]; then
        	mysqldump --defaults-extra-file=/usr/local/share/blog_config_mysql.cnf --default-character-set=utf8 blog_entries > "$file_name"
		mysql_err="$?"
	else
		docker-compose exec mysql_blog_interface mysqldump --defaults-extra-file=/usr/local/share/blog_config_mysql.cnf --default-character-set=utf8 blog_entries > "$file_name"
		mysql_err="$(docker-compose exec mysql_blog_interface echo "$?")"
	fi

        AFTER_DUMP=$(<"$file_name")

	# Checks MySQL exit code & if the snapshots are different to determine success.
        if [ "$BEFORE_DUMP" != "$AFTER_DUMP" ] && [ "$mysql_err" == "0" ]; then
                echo "Backup successful."
		exit 0
        else
                echo "Something went wrong. Your backup was not updated."
		exit 1
        fi
}


# This function was built to help facilitate development.
function local_publish() {
	# Moves necessary files to a $PATH directory for ease of access.
        cp blog_module /usr/local/bin/blog_module
        cp blog /usr/local/bin/blog

	# Report results to user.
        if [ "$?" -eq 0 ]; then
                echo -e "Publish to /usr/local/bin successful.\nYou may now run commands using:\n\tblog ..."
		exit 0
        else
                echo "Something went wrong."
		exit 1
        fi
}


# A help function for the user to get their bearings.
function blog_help() {
	echo -e "Actions:\n\tread\n\twrite\n\tedit\n\tdelete\n\tbackup\n\thelp\n"
	echo -e "Options:\n\t[-e entry_number]\n\t[-f file_name]\n"
	echo -e "Examples:\n\tblog read -e all\n\tblog write -f prewritten_entry.txt\n\tblog edit -e 6 -f file_to_work_in.txt\n\tblog delete -e last"
}
